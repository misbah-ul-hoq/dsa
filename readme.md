# Problem solving patterns

- ### Naive (This is easy but not efficient)
- ### Frequency counter
  Create one or more object/s to keep track of the frequency, And then solve the problem
- ### Multiple pointers
  Create two or more pointers to keep track of changes.. Return the required change at the end
- ### Sliding Window
  Create a variable to store data. Then slide that variable...
- ### Divide and Conquer
  This is found in binary search, merge sort, quick sort etc.....

# Searching Algorithms

### Linear Search (Time Complexity -- O(n))

### Binary Search (Time Complexity -- O(log n))

# Sorting Algorithms

### Bubble Sort (Time complexity -- O(n<sup>2</sup>))

Loop over the array and compare items. After the first iteration the largest number goes to the last index. So the next time we loop till the second last element. And this is how bubble sort works by sending the large numbers to the end.

### Selection Sort (Time complexity -- O(n<sup>2</sup>))

### Insertion Sort (Time complexity -- O(n<sup>2</sup>))

### Merge Sort (Time complexity -- O(n logn))

### Quick Sort (Time complexity -- O(n logn) (average case))

### Radix Sort (Time complexity -- O(n logn) )
